.data
sep: .asciz " " #строка-разделитель
.text
.macro fill(%arr %len) # Заполнение массива, передаются параметры - указатель на начало массива и длина этого массива
	addi sp sp -20 # Выделяем память в стеке
	sw ra 16(sp) # Сохраняем стек пойинтер, входяшие параметры и локальные переменные в стек
	sw %arr 12(sp)
	sw %len 8(sp)
	sw s0 4(sp)
	sw s1 (sp)
	mv s1 %arr
	fill_for:	bge s0 %len end_fill # заполняем циклом for
		li a7 5
		ecall
		sw %arr (s1) # сохраняем число в массив
		addi s0 s0 1 
		addi s1 s1 4 # cдвигаем на следующую ячейку
		j fill_for
	end_fill:
		lw s1 (sp) #восстанавливаем регистры из стека
		lw s0 4(sp)	
		lw %len 8(sp)
		lw %arr 12(sp)
		lw ra 16(sp)
		addi sp sp 20
		.end_macro 
		
.macro print(%arr %len) # Печать массива на экран, передаются параметры - указатель на начало массива и длина этого массива
	addi sp sp -20 # Выделяем память в стеке
	sw ra 16(sp) # Сохраняем стек пойинтер, входяшие параметры и локальные переменные в стек
	sw %arr 12(sp)
	sw %len 8(sp)
	sw s0 4(sp)
	sw s1 (sp)
	li s0 0 
	mv s1 %arr
	print_for: bge s0 %len end_print # печатаем на экран циклом for
		li a7 1
		lw a0 (s1) # достаем число из массива и печатаем его
		ecall
		li a7 4 
		la a0 sep 
		ecall
		addi s0 s0 1
		addi s1 s1 4 #сдвигаем на следующуб ячейку
		j print_for
	end_print:
		lw s1 (sp) #восстанавливаем регистры из стека
		lw s0 4(sp)	
		lw %len 8(sp)
		lw %arr 12(sp)
		lw ra 16(sp)
		addi sp sp 20
		.end_macro
.macro sort(%from %len %to) # макрос сортировки, параметры: %from - указатель на массив, откуда берем числа, %len - длина массива, %to - указатель на массив, куда кладем отсортированные элементы массива %from
	addi sp sp -20 # выделяем память в стеке
	sw ra 16(sp) # Сохраняем стек пойинтер, входяшие параметры и локальные переменные в стек
	sw s1 12(sp)
	sw s2 8(sp)
	sw s3 4(sp)
	sw s4 (sp)
	li t0 0
	mv t1 %from
	mv s1 %to
	sort_for: bge t0 %len end_sort 
		lw t2 (t1)	#выбираем текущий элемент массива %from 
		sw t2 (s1)	#кладем этот элемент в массив to
		mv s3 s2	#копируем размер массива как позицию текущего элемента, которую будем сдвигать
		addi s4 s1 -4
		insertion_while: beqz s3 end_insertion #передвигаем этот элемент влево, пока он не встанет на свое место
			lw t3 (s4) #так же если элементов меньше текущего нет, он встает в левый край, для этого условие выхода из цикла - счетчик позиции элемента = 0
			if_less_prev: bgt t2 t3 end_insertion #если текущий элемент меньше предыдущего, то меняем их местами
				sw t3 4(s4) #кладем соседний слева элемент на место нашего
				sw t2 (s4) #кладем наш элемент левее
				addi s3 s3 -1 #сдвигаем счетчик позиции текущего элемента назад
				addi s4 s4 -4 #смотрим следующий слева элемент
				j insertion_while
		end_insertion: #вставка произошла успешно, идем на следующую итерацию
		addi t0 t0 1 #счетчик цикла по n
		addi s2 s2 1 #счетчик размера второго массива
		addi t1 t1 4 #сдвиг указателя 1 массива
		addi s1 s1 4 #сдвиг указателя 2 массива
		j sort_for
	end_sort: 
		lw s4 (sp) #восстанавливаем регистры из стека, результат хранится в том же регистре %to
		lw s3 4(sp)
		lw s2 8(sp)
		lw s1 12(sp)
		lw ra 16(sp)
		addi sp sp 20
		.end_macro
