<img width="360" alt="image" src="https://github.com/Intellectual23/ABC/assets/68235201/9d5064b3-e4f4-4877-96e7-d1695b1d9a29">Калашников Егор Игоревич

БПИ226

Вариант 21

[Тесты](tests.md)

[Подпрограмма тестирования](testing.asm)

[Основная программа с комментариями](main.asm)

[Библиотека макросов с комментариями](macros.asm)

Отчёт:
1) Сначала сделал все в одном файле(на 4-5):
  -  Выделяю память 40 байт для массива А(тк максимум 10 чисел), и 40 байт для массива B
  -  Получаю с клавиатуры число элементов в массиве, и осуществляю проверку. В случае если число больше 10, устанавливаю размер 10, в случае если размер меньше 1, устанавливаю размер 1.
  -  Вызываю подпрограмму для заполнения массива А, позже оберну ее в макрос. Сразу передаю в качестве параметров ссылку на массив а, и размер массива (регистры a0 и a1)
  -  После заполнения массива А вызываю подпрограмму(тоже потом оберну в макрос), которая записывает в массив B элементы массива А, в порядке возрастания. На вход передаются ссылка на массив, из которого берутся элементы, размер массива, и ссылка на массив, куда запишутся отсортированные элементы.
  -  После этого вызываю подпрограмму печати на экран всех элементов массива B(позже тоже оберну в макрос). На вход передаются так же ссылка на массив и размер массива.

2) (на 6-7-8)
- После этого, __согласно критериям__, в каждой подпрограмме, сохранил параметры в регистрах a на стек, а так же сделал локальные переменные регистроы s, которые так же сохранял на стек. Это улобно, тк вне подпрограммы они остаются нулевыми, и их не нужно обнулять в других подпрограммах.
- Так же входные параметры меняются внутри подпрограммы, но на выходе сохраняются. При этом сами подпрограммы поддерживают многократное использование с различными наборами исходных данных, включая возможность подключения различных исходных и результирующих массивов.
- Сделал тестирубщую программу, в соответствии с требованием: *"Все гораздо проще. Создать дополнительную тестовую программу, в которой прописаны массивы с разными тестовыми данными, а также количество обрабатываемых элементов. Вручную массивы вводить не нужно. После этого многократно повторить для каждого массива:
1. Вызов подпрограммы вывода тестового массива
2. Вызов подпрограммы формирования массива В
3. Снова вызов подпрограммы вывода, но уже массива B
Результаты проверки - визуально.
Но в принципе могуть дополнительно добавить сравнение формируемого B с ожидаемым результатом. Но это необязательно..."*
  
3) (на 9-10) 
- После этого я обернул подпрограмму заполнения массива, вывода массива и сортировки в макросы, входные параметры переименовал как %arr, %len, %from, %to, оставил работу со стеком. Код стал проще для восприятия. 
- Все макросы перенес в отдельную библиотеку - macros.asm, и подключил ее к программе main.
- Программа получилась разбита на несколько единиц компиляции.
- При этом подпрограммы составляют унифицированные модули, используемые повторно как в программе, осуществляющей ввод исходных данных, так и в тестовой программе.

4) Как работает мой алгоритм сортировки: 
- Иду по всем элементам массива А, приписываю текущий элемент массива А в конец массива Б, и затем двигаю этот элемент в массиве Б назад до тех пор, пока он не займет подходящую позицию относительно других.
- Подходящую позицию займет тогда, когда слева от него не будет элементов меньше его, а чтобы подвинуть элемент, просто меняю местами его и соседний.
- Таким образом массив Б на каждой итерации внешнего цикла отсортирован по возрастанию, этот алгоритм называется Insertion Sort.

Конец!
