Калашников Егор Игоревич

БПИ226

Вариант 21

[Тесты](tests.md)

[Подпрограмма тестирования](testing.asm)

[Основная программа с комментариями](main.asm)

[Библиотека макросов с комментариями](macros.asm)

Отчёт:
1) Сначала сделал все в одном файле(на 4-5):
  -  Выделяю память 40 байт для массива А(тк максимум 10 чисел), и 40 байт для массива B
  -  Получаю с клавиатуры число элементов в массиве, и осуществляю проверку. В случае если число больше 10, устанавливаю размер 10, в случае если размер меньше 1, устанавливаю размер 1.
  -  Вызываю подропрограмму для заполнения массива А, позже оберну ее в макрос. Сразу передаю в качестве параметров ссылку на массив а, и размер массива (регистры a0 и a1)
  -  После заполнения массива А вызываю подпрограмму, которая записывает в массив B элементы массива А, в порядке возрастания. На вход передаются ссылка на массив, из которого берутся элементы, размер массива, и ссылка на массив, куда запишутся отсортированные элементы.
  -  После этого вызываю подпрограмму печати на экран всех элементов массива B. На вход передаются так же ссылка на массив и размер массива.
  -  Позже в конец добавлю вызов подпрограммы тестирования

2) (на 6-7-8, потом будет про тестовую подпрограмму)
- После этого, __согласно критериям__, в каждой подпрограмме, сохранил параметры в регистрах a на стек, а так же сделал локальные переменные регистроы s, которые так же сохранял на стек. Это улобно, тк вне подпрограммы они остаются нулевыми, и их не нужно обнулять в других подпрограммах.
- Так же входные параметры меняются внутри подпрограммы, но на выходе сохраняются. При этом сами подпрограммы поддерживают многократное использование с различными наборами исходных данных, включая возможность подключения различных исходных и результирующих массивов.
  
3) (на 9-10) 
- После этого я обернул подпрограмму заполнения массива, вывода массива и сортировки в макросы, входные параметры переименовал как %arr, %len, %from, %to, оставил работу со стеком. Код стал проще для восприятия. 
- Все макросы перенес в отдельную библиотеку - macros.asm, и подключил ее к программе main.
- Программа получилась разбита на несколько единиц компиляции.
- При этом подпрограммы составляют унифицированные модули, используемые повторно как в программе, осуществляющей ввод исходных данных, так и в тестовой подпрограмме.

4) Тестовая подпрограмма:
- В ней я создаю массив, который заполняю не с клавиатуры, а вручную(li и sw)
- Далее создаю второй массив, который заполняю так же вручную, но уже отсортированными значениями прошлого массива. В нем хранится правильный ответ
- Запускаю макрос сортировки, в который передаю ссылку на первый массив и на новый третий, в котором окажутся отсортированные элементы первого массива
- С помощью макроса печати массивов печатаю сначала второй массив, затем третий и таким образом можно убедиться что мой алгоритм работает правильно.
- Повторяю это еще 2 раза, для двух других тестов. Просто копирую тот же самый код)

5) Как работает мой алгоритм сортировки: 
- Иду по всем элементам массива А, приписываю текущий элемент массива А в конец массива Б, и затем двигаю этот элемент в массиве Б назад до тех пор, пока он не займет подходящую позицию относительно других.
- Подходящую позицию займет тогда, когда слева от него не будет элементов меньше его, а чтобы подвинуть элемент, просто меняю местами его и соседний.
- Таким образом массив Б на каждой итерации внешнего цикла отсортирован по возрастанию, этот алгоритм называется Insertion Sort.

Конец!
